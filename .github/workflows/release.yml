# =============================================================================
# IMMERSED RELEASE WORKFLOW
# =============================================================================
# NOTE: This is a COPY of the workflow that runs in the immersed-releases repo.
# The ACTUAL workflow that builds and releases the app is located at:
#   https://github.com/emilstepanian/immersed-releases/.github/workflows/release.yml
#
# This file is kept here for reference only. If you need to make changes to the
# release process, update the workflow in the immersed-releases repo, then copy
# it here for documentation purposes.
# =============================================================================

name: Build and Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Version tag (e.g., v1.4.1)"
        required: true
  repository_dispatch:
    types: [create-release]

jobs:
  cleanup-old-artifacts:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout public releases repo
        uses: actions/checkout@v3

      - name: Cleanup old artifacts
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            // Get all tags to map commits to version tags
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const tagMap = new Map();
            for (const tag of tags) {
              if (tag.name.startsWith('v')) {
                tagMap.set(tag.commit.sha, tag.name);
              }
            }

            // Get all workflow runs
            const { data: workflows } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'release.yml',
              per_page: 100
            });

            // Filter runs that were triggered and map them to their tags
            const versionRuns = [];
            for (const run of workflows.workflow_runs) {
              // Try to extract tag from run name or use head_sha
              const tag = tagMap.get(run.head_sha);
              if (tag && tag.startsWith('v')) {
                versionRuns.push({ ...run, versionTag: tag });
              }
            }

            // Group by version tag and get the latest run for each version
            const versionMap = new Map();
            for (const run of versionRuns) {
              const tag = run.versionTag;
              if (!versionMap.has(tag) || new Date(run.created_at) > new Date(versionMap.get(tag).created_at)) {
                versionMap.set(tag, run);
              }
            }

            // Sort by creation date (newest first)
            const sortedVersions = Array.from(versionMap.values())
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            // Keep only the 3 latest versions
            const versionsToKeep = sortedVersions.slice(0, 3);
            const versionsToDelete = sortedVersions.slice(3);

            console.log(`Keeping artifacts from ${versionsToKeep.length} latest versions: ${versionsToKeep.map(v => v.versionTag).join(', ')}`);
            console.log(`Deleting artifacts from ${versionsToDelete.length} older versions: ${versionsToDelete.map(v => v.versionTag).join(', ')}`);

            // Get all artifacts and delete those from old versions
            for (const runToDelete of versionsToDelete) {
              try {
                const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: runToDelete.id
                });

                for (const artifact of artifacts.artifacts) {
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id
                  });
                  console.log(`Deleted artifact: ${artifact.name} from run ${runToDelete.id} (${runToDelete.versionTag})`);
                }
              } catch (error) {
                console.log(`Error cleaning up artifacts for run ${runToDelete.id}: ${error.message}`);
              }
            }

  build-mac-intel:
    needs: cleanup-old-artifacts
    runs-on: macos-latest
    steps:
      - name: Get tag name for checkout
        id: get_tag_for_build
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG_NAME="${{ github.event.client_payload.tag }}"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
          else
            TAG_NAME="HEAD"
          fi
          # Ensure tag has 'v' prefix if it's not HEAD and doesn't start with 'v'
          if [ "$TAG_NAME" != "HEAD" ] && [[ ! "$TAG_NAME" =~ ^v ]]; then
            TAG_NAME="v$TAG_NAME"
          fi
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Using tag for checkout: $TAG_NAME"

      - name: Checkout private source repo
        uses: actions/checkout@v3
        with:
          repository: emilstepanian/immersed
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0
          ref: ${{ steps.get_tag_for_build.outputs.TAG_NAME }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Import Apple Certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate
          echo -n "$APPLE_CERTIFICATE" | base64 --decode --output $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Set keychain to not timeout during build
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" $KEYCHAIN_PATH

          # Verify certificate is imported correctly
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Build for macOS Intel
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          VITE_FIREBASE_API_KEY: ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN: ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID: ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET: ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID: ${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_MEASUREMENT_ID: ${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
          VITE_STRIPE_PRICE_PRO_MONTHLY: ${{ secrets.VITE_STRIPE_PRICE_PRO_MONTHLY }}
          VITE_STRIPE_PRICE_PRO_ANNUAL: ${{ secrets.VITE_STRIPE_PRICE_PRO_ANNUAL }}
          VITE_STRIPE_PRICE_LIFETIME: ${{ secrets.VITE_STRIPE_PRICE_LIFETIME }}
          VITE_WEB_URL: ${{ secrets.VITE_WEB_URL }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
        run: npm run build:mac:x64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-mac-intel
          path: release/*

  build-mac-arm:
    needs: cleanup-old-artifacts
    runs-on: macos-latest
    steps:
      - name: Get tag name for checkout
        id: get_tag_for_build
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG_NAME="${{ github.event.client_payload.tag }}"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
          else
            TAG_NAME="HEAD"
          fi
          # Ensure tag has 'v' prefix if it's not HEAD and doesn't start with 'v'
          if [ "$TAG_NAME" != "HEAD" ] && [[ ! "$TAG_NAME" =~ ^v ]]; then
            TAG_NAME="v$TAG_NAME"
          fi
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Using tag for checkout: $TAG_NAME"

      - name: Checkout private source repo
        uses: actions/checkout@v3
        with:
          repository: emilstepanian/immersed
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0
          ref: ${{ steps.get_tag_for_build.outputs.TAG_NAME }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Import Apple Certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate
          echo -n "$APPLE_CERTIFICATE" | base64 --decode --output $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Set keychain to not timeout during build
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" $KEYCHAIN_PATH

          # Verify certificate is imported correctly
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Build for macOS Apple Silicon
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          VITE_FIREBASE_API_KEY: ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN: ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID: ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET: ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID: ${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_MEASUREMENT_ID: ${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
          VITE_STRIPE_PRICE_PRO_MONTHLY: ${{ secrets.VITE_STRIPE_PRICE_PRO_MONTHLY }}
          VITE_STRIPE_PRICE_PRO_ANNUAL: ${{ secrets.VITE_STRIPE_PRICE_PRO_ANNUAL }}
          VITE_STRIPE_PRICE_LIFETIME: ${{ secrets.VITE_STRIPE_PRICE_LIFETIME }}
          VITE_WEB_URL: ${{ secrets.VITE_WEB_URL }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
        run: npm run build:mac:arm64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-mac-arm
          path: release/*

  build-windows:
    needs: cleanup-old-artifacts
    runs-on: windows-latest
    steps:
      - name: Get tag name for checkout
        id: get_tag_for_build
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG_NAME="${{ github.event.client_payload.tag }}"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
          else
            TAG_NAME="HEAD"
          fi
          # Ensure tag has 'v' prefix if it's not HEAD and doesn't start with 'v'
          if [ "$TAG_NAME" != "HEAD" ] && [[ ! "$TAG_NAME" =~ ^v ]]; then
            TAG_NAME="v$TAG_NAME"
          fi
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Using tag for checkout: $TAG_NAME"

      - name: Checkout private source repo
        uses: actions/checkout@v3
        with:
          repository: emilstepanian/immersed
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0
          ref: ${{ steps.get_tag_for_build.outputs.TAG_NAME }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Build for Windows
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          VITE_FIREBASE_API_KEY: ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN: ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_PROJECT_ID: ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET: ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID: ${{ secrets.VITE_FIREBASE_APP_ID }}
          VITE_FIREBASE_MEASUREMENT_ID: ${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }}
          VITE_STRIPE_PUBLISHABLE_KEY: ${{ secrets.VITE_STRIPE_PUBLISHABLE_KEY }}
          VITE_STRIPE_PRICE_PRO_MONTHLY: ${{ secrets.VITE_STRIPE_PRICE_PRO_MONTHLY }}
          VITE_STRIPE_PRICE_PRO_ANNUAL: ${{ secrets.VITE_STRIPE_PRICE_PRO_ANNUAL }}
          VITE_STRIPE_PRICE_LIFETIME: ${{ secrets.VITE_STRIPE_PRICE_LIFETIME }}
          VITE_WEB_URL: ${{ secrets.VITE_WEB_URL }}
          VITE_SENTRY_DSN: ${{ secrets.VITE_SENTRY_DSN }}
        run: npm run build:win:x64

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-windows
          path: release/*

  release:
    needs: [build-mac-intel, build-mac-arm, build-windows]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout public releases repo
        uses: actions/checkout@v3

      - name: Checkout private source repo (for tag info)
        uses: actions/checkout@v3
        with:
          repository: emilstepanian/immersed
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0
          path: source-repo

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Prepare release files
        run: |
          mkdir -p release

          # Copy non-yml files first (these don't conflict)
          find release-artifacts -type f \( -name "*.dmg" -o -name "*.zip" -o -name "*.exe" -o -name "*.blockmap" \) -exec cp {} release/ \;

          # Handle yml files - need to rename arm64 version to prevent overwrite
          # Intel build creates: latest-mac.yml
          # ARM build also creates: latest-mac.yml (would overwrite)
          # We need: latest-mac.yml (Intel) and latest-mac-arm64.yml (ARM)

          # Copy Intel yml files
          if [ -f "release-artifacts/release-mac-intel/latest-mac.yml" ]; then
            cp release-artifacts/release-mac-intel/latest-mac.yml release/latest-mac.yml
            echo "✓ Copied Intel latest-mac.yml"
          fi

          # Copy and rename ARM yml files for electron-updater to detect ARM architecture
          if [ -f "release-artifacts/release-mac-arm/latest-mac.yml" ]; then
            cp release-artifacts/release-mac-arm/latest-mac.yml release/latest-mac-arm64.yml
            echo "✓ Copied ARM latest-mac.yml as latest-mac-arm64.yml"
          fi

          # Copy Windows yml
          if [ -f "release-artifacts/release-windows/latest.yml" ]; then
            cp release-artifacts/release-windows/latest.yml release/latest.yml
            echo "✓ Copied Windows latest.yml"
          fi

          # Copy any other yml files that might exist (app-update.yml, builder-debug.yml, etc.)
          find release-artifacts -name "*.yml" ! -name "latest-mac.yml" ! -name "latest.yml" -exec cp {} release/ \; 2>/dev/null || true

          echo ""
          echo "Release files prepared:"
          ls -la release/

      - name: Get tag name and release notes
        id: get_tag
        run: |
          cd source-repo
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.tag }}"
            RELEASE_NOTES=$(git tag -l --format='%(contents)' "$TAG_NAME" 2>/dev/null || echo "Release $TAG_NAME")
          elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            TAG_NAME="${{ github.event.client_payload.tag }}"
            RELEASE_NOTES=$(git tag -l --format='%(contents)' "$TAG_NAME" 2>/dev/null || echo "Release $TAG_NAME")
          else
            TAG_NAME=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$TAG_NAME" ]; then
              echo "ERROR: Could not determine tag name"
              exit 1
            fi
            RELEASE_NOTES=$(git tag -l --format='%(contents)' "$TAG_NAME" 2>/dev/null || echo "Release $TAG_NAME")
          fi
          cd ..
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Using tag: $TAG_NAME"

      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v1
        with:
          files: release/*
          tag_name: ${{ steps.get_tag.outputs.TAG_NAME }}
          name: ${{ steps.get_tag.outputs.TAG_NAME }}
          body: ${{ steps.get_tag.outputs.RELEASE_NOTES }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
